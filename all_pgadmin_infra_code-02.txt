### .github/workflows/checks.yml ###
name: Terraform Checks

on:
  pull_request:
    branches: [ "main" ]

jobs:
  terraform-checks:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform fmt check
        run: terraform fmt -check -recursive

      - name: Terraform validate
        run: terraform validate

      - name: Terraform init
        run: terraform init

      - name: Terraform plan (check only)
        run: terraform plan

### .github/workflows/deploy.yml ###
name: Deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

jobs:
  deploy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform init
        run: terraform init

      - name: Terraform plan
        run: terraform plan -out=tfplan

      - name: Terraform apply
        run: terraform apply -auto-approve tfplan

### .github/workflows/destroy.yml ###
name: Destroy

on:
  workflow_dispatch: {}

jobs:
  destroy:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - uses: hashicorp/setup-terraform@v3

      - name: Terraform init
        run: terraform init

      - name: Terraform destroy
        run: terraform destroy -auto-approve

### .github/workflows/test-and-lint.yml ###
name: Test & Lint

on:
  pull_request:

jobs:
  lint:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - name: Terraform fmt (check)
        run: terraform fmt -check -recursive
      - name: Terraform init (no backend)
        run: terraform init -backend=false
      - name: Terraform validate
        run: terraform validate

### terraform/locals.tf ###
locals {
  prefix = "pgadmin"
  tags   = merge({ ManagedBy = "Terraform" }, var.tags)
}

### terraform/main.tf ###
#################################
# EFS for pgAdmin (and Marquez) #
#################################

module "efs" {
  source = "../modules/efs"

  name       = local.prefix
  vpc_id     = var.vpc_id
  subnet_ids = var.private_subnet_ids
  tags       = local.tags

  create_security_group = true

  access_points = [
    {
      name        = "pgadmin"
      path        = "/pgadmin"
      uid         = 5050
      gid         = 5050
      permissions = "750"
    },
    {
      name        = "marquez"
      path        = "/marquez"
      uid         = 1000
      gid         = 1000
      permissions = "750"
    }
  ]
}

###############
# ECR for App #
###############

module "ecr" {
  source = "../modules/ecr"

  name = "pgadmin"
  tags = local.tags
}

##############
# IAM Roles  #
##############

module "iam" {
  source = "../modules/iam"

  name = "pgadmin"
  tags = local.tags
}

###################
# Security Groups #
###################

module "security_groups" {
  source = "../modules/security_groups"

  name           = "pgadmin"
  vpc_id         = var.vpc_id
  container_port = 80
  tags           = local.tags
}

########################
# Secrets for pgAdmin  #
########################

module "secrets" {
  source = "../modules/secrets"

  name             = "pgadmin"
  pgadmin_email    = "admin@example.com"
  pgadmin_password = "SuperSecretPassword!"
  tags             = local.tags
}

###############
# ECS Service #
###############

module "ecs" {
  source = "../modules/ecs"

  name                 = "pgadmin"
  execution_role_arn   = module.iam.execution_role_arn
  task_role_arn        = module.iam.task_role_arn
  ecr_repo_url         = module.ecr.repository_url
  image_tag            = var.image_tag
  efs_id               = module.efs.file_system_id
  efs_access_point_id  = module.efs.access_point_ids_by_name["pgadmin"]
  ecs_sg_id            = module.security_groups.ecs_sg_id
  alb_target_group_arn = module.alb.target_group_arn
  private_subnet_ids   = var.private_subnet_ids
  public_subnet_ids    = var.public_subnet_ids
  pgadmin_secret_arn   = module.secrets.pgadmin_secret_arn
  region               = var.region
  tags                 = local.tags
}

###################
# Application LB  #
###################

module "alb" {
  source = "../modules/alb"

  name              = "pgadmin"
  vpc_id            = var.vpc_id
  public_subnet_ids = var.public_subnet_ids
  sg_id             = module.security_groups.ecs_sg_id
  container_port    = 80
  tags              = local.tags
}

###################################
# ECS Autoscaling for pgAdmin     #
###################################

module "pgadmin_autoscaling" {
  source       = "../modules/autoscaling"
  name         = "pgadmin"
  cluster_name = module.ecs.ecs_cluster_name
  service_name = module.ecs.ecs_service_name

  min_capacity        = 1
  max_capacity        = 3
  cpu_target_value    = 70
  memory_target_value = 75
  tags                = local.tags
}

###################################
# CloudWatch alerts for pgAdmin   #
###################################

module "pgadmin_cloudwatch" {
  source       = "../modules/cloudwatch"
  name         = "pgadmin"
  cluster_name = module.ecs.ecs_cluster_name
  service_name = module.ecs.ecs_service_name
  alert_email  = "mm_soso33@yahoo.com"

  cpu_alarm_threshold    = 80
  memory_alarm_threshold = 85
  tags                   = local.tags
}

######################
# VPC Endpoints (VPCE)
######################
module "vpc_endpoints" {
  source = "../modules/vpc_endpoints"

  name                    = "pgadmin"
  vpc_id                  = var.vpc_id
  region                  = var.region
  subnet_ids              = var.private_subnet_ids
  sg_id                   = null # set to module.security_groups.ecs_sg_id if you want to reuse ECS SG; else module creates one
  private_route_table_ids = var.private_route_table_ids
  tags                    = local.tags
}

### terraform/outputs.tf ###
output "efs_id" {
  description = "EFS filesystem ID"
  value       = module.efs.file_system_id
}

output "efs_sg_id" {
  description = "Security group attached to EFS mount targets"
  value       = module.efs.security_group_id
}

output "efs_access_points" {
  description = "Map of access point names to IDs"
  value       = module.efs.access_point_ids_by_name
}

### terraform/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region for pgAdmin deployment"
}

variable "vpc_id" {
  type        = string
  default     = "vpc-0acff19cbcdd28123"
  description = "Existing VPC ID"
}

variable "public_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0096b55bfec0fc1b7",
    "subnet-0baa7f08adef5addb",
    "subnet-03be7e34785dcc9ed"
  ]
  description = "Public subnets for ALB"
}

variable "private_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0f15865ff763a4cd2",
    "subnet-05fe1790c8745cf07",
    "subnet-05a98b6683351fe11"
  ]
  description = "Private subnets for ECS tasks and EFS mount targets"
}

variable "nated_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0c30e0a79884dfd82",
    "subnet-043c7e91ecd807a0c",
    "subnet-063f7cf49a5ac401c"
  ]
  description = "NAT subnets (optional, if needed for endpoints)"
}

variable "tags" {
  type    = map(string)
  default = { Project = "pgadmin" }
}

variable "private_route_table_ids" {
  type        = list(string)
  default     = []
  description = "Private route table IDs for S3 gateway endpoint (optional)"
}

variable "image_tag" {
  type        = string
  description = "Docker image tag for pgAdmin"
  default     = "latest"
}

### terraform/versions.tf ###
terraform {
  required_version = ">= 1.3.0"

  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "pgadmin/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks"
    encrypt        = true
  }

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

### modules/alb/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/alb/main.tf ###
#####################
# Application LB     #
#####################

resource "aws_lb" "this" {
  name               = "${var.name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [var.sg_id]
  subnets            = var.public_subnet_ids

  enable_deletion_protection = false

  tags = merge(var.tags, { Name = "${var.name}-alb" })
}

#####################
# Target Group       #
#####################

resource "aws_lb_target_group" "this" {
  name        = "${var.name}-tg"
  port        = var.container_port
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = var.vpc_id

  health_check {
    path                = "/"
    protocol            = "HTTP"
    matcher             = "200-399"
    interval            = 30
    timeout             = 5
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }

  tags = merge(var.tags, { Name = "${var.name}-tg" })
}

#####################
# Listener           #
#####################

resource "aws_lb_listener" "http" {
  load_balancer_arn = aws_lb.this.arn
  port              = 80
  protocol          = "HTTP"

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.this.arn
  }
}

### modules/alb/outputs.tf ###
output "alb_dns_name" {
  value       = aws_lb.this.dns_name
  description = "DNS name of the ALB"
}

output "target_group_arn" {
  value       = aws_lb_target_group.this.arn
  description = "ARN of the ALB target group"
}

output "listener_arn" {
  value       = aws_lb_listener.http.arn
  description = "ARN of the ALB listener"
}

### modules/alb/variables.tf ###
variable "name" {
  type        = string
  description = "Base name prefix"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "public_subnet_ids" {
  type        = list(string)
  description = "List of public subnet IDs for ALB"
}

variable "sg_id" {
  type        = string
  description = "Security group for ALB"
}

variable "container_port" {
  type        = number
  default     = 80
  description = "Container port that ALB will forward traffic to"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply"
}

### modules/autoscaling/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/autoscaling/main.tf ###
#############################
# ECS Service Autoscaling   #
#############################

resource "aws_appautoscaling_target" "ecs" {
  max_capacity       = var.max_capacity
  min_capacity       = var.min_capacity
  resource_id        = "service/${var.cluster_name}/${var.service_name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}

resource "aws_appautoscaling_policy" "cpu" {
  name               = "${var.name}-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    target_value       = var.cpu_target_value
    scale_in_cooldown  = 60
    scale_out_cooldown = 60
  }
}

resource "aws_appautoscaling_policy" "memory" {
  name               = "${var.name}-memory-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageMemoryUtilization"
    }
    target_value       = var.memory_target_value
    scale_in_cooldown  = 60
    scale_out_cooldown = 60
  }
}

### modules/autoscaling/outputs.tf ###
output "autoscaling_target_id" {
  value       = aws_appautoscaling_target.ecs.resource_id
  description = "Resource ID for ECS autoscaling"
}

### modules/autoscaling/variables.tf ###
variable "name" {
  type        = string
  description = "Application name (used as prefix)"
}

variable "cluster_name" {
  type        = string
  description = "ECS Cluster name"
}

variable "service_name" {
  type        = string
  description = "ECS Service name"
}

variable "min_capacity" {
  type        = number
  default     = 1
}

variable "max_capacity" {
  type        = number
  default     = 3
}

variable "cpu_target_value" {
  type        = number
  default     = 70
  description = "Target CPU utilization % for autoscaling"
}

variable "memory_target_value" {
  type        = number
  default     = 75
  description = "Target Memory utilization % for autoscaling"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply where supported"
}

### modules/cloudwatch/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/cloudwatch/main.tf ###
#################################
# CloudWatch Alarms + SNS Alerts
#################################

resource "aws_sns_topic" "alerts" {
  name = "${var.name}-alerts"
  tags = local.common_tags
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# Alarm for high CPU
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "${var.name}-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "CPUUtilization"
  namespace           = "AWS/ECS"
  period              = 60
  statistic           = "Average"
  threshold           = var.cpu_alarm_threshold
  alarm_description   = "High CPU on ${var.service_name}"
  alarm_actions       = [aws_sns_topic.alerts.arn]

  dimensions = {
    ClusterName = var.cluster_name
    ServiceName = var.service_name
  }

  tags = local.common_tags
}

# Alarm for high Memory
resource "aws_cloudwatch_metric_alarm" "memory_high" {
  alarm_name          = "${var.name}-memory-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "MemoryUtilization"
  namespace           = "AWS/ECS"
  period              = 60
  statistic           = "Average"
  threshold           = var.memory_alarm_threshold
  alarm_description   = "High Memory on ${var.service_name}"
  alarm_actions       = [aws_sns_topic.alerts.arn]

  dimensions = {
    ClusterName = var.cluster_name
    ServiceName = var.service_name
  }

  tags = local.common_tags
}

### modules/cloudwatch/outputs.tf ###
output "sns_topic_arn" {
  description = "SNS topic ARN for alerts"
  value       = aws_sns_topic.alerts.arn
}

output "cpu_alarm_arn" {
  description = "CloudWatch alarm ARN for high CPU"
  value       = aws_cloudwatch_metric_alarm.cpu_high.arn
}

output "memory_alarm_arn" {
  description = "CloudWatch alarm ARN for high Memory"
  value       = aws_cloudwatch_metric_alarm.memory_high.arn
}

### modules/cloudwatch/variables.tf ###
variable "name" {
  type        = string
  description = "Application name (prefix for alarms and topics)"
}

variable "cluster_name" {
  type        = string
  description = "ECS Cluster name"
}

variable "service_name" {
  type        = string
  description = "ECS Service name"
}

variable "alert_email" {
  type        = string
  description = "Email to subscribe to SNS alerts"
}

variable "cpu_alarm_threshold" {
  type        = number
  default     = 80
  description = "CPU threshold % for alarm"
}

variable "memory_alarm_threshold" {
  type        = number
  default     = 85
  description = "Memory threshold % for alarm"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply to SNS/alarms"
}

### modules/codedeploy/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/codedeploy/main.tf ###
#############################
# CodeDeploy ECS Application
#############################

resource "aws_codedeploy_app" "this" {
  name             = "${var.name}-ecs-app"
  compute_platform = "ECS"
  tags             = local.common_tags
}

#############################
# CodeDeploy ECS Deployment Group
#############################

resource "aws_codedeploy_deployment_group" "this" {
  app_name               = aws_codedeploy_app.this.name
  deployment_group_name  = "${var.name}-ecs-dg"
  service_role_arn       = var.codedeploy_role_arn
  deployment_config_name = "CodeDeployDefault.ECSAllAtOnce"

  ecs_service {
    cluster_name = var.ecs_cluster_name
    service_name = var.ecs_service_name
  }

  load_balancer_info {
    target_group_pair_info {
      target_group {
        name = "${var.name}-tg"
      }
      prod_traffic_route {
        listener_arns = [var.alb_listener_arn]
      }
    }
  }

  auto_rollback_configuration {
    enabled = true
    events  = ["DEPLOYMENT_FAILURE"]
  }

  tags = local.common_tags
}

### modules/codedeploy/outputs.tf ###
output "codedeploy_app_name" {
  value       = aws_codedeploy_app.this.name
  description = "CodeDeploy application name"
}

output "codedeploy_deployment_group_name" {
  value       = aws_codedeploy_deployment_group.this.deployment_group_name
  description = "CodeDeploy deployment group name"
}

### modules/codedeploy/variables.tf ###
variable "name" {
  type        = string
  default     = "pgadmin"
  description = "Prefix for CodeDeploy resources"
}

variable "ecs_cluster_name" {
  type        = string
  description = "ECS cluster name"
}

variable "ecs_service_name" {
  type        = string
  description = "ECS service name"
}

variable "codedeploy_role_arn" {
  type        = string
  description = "IAM role ARN for CodeDeploy"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Common tags"
}

variable "alb_listener_arn" {
  type        = string
  description = "ALB Listener ARN for CodeDeploy"
}

### modules/ecr/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/ecr/main.tf ###
resource "aws_ecr_repository" "pgadmin" {
  name                 = var.name
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  tags = merge(
    var.tags,
    {
      Name = var.name
    }
  )
}

# Optional lifecycle policy - keep only the last 10 images
resource "aws_ecr_lifecycle_policy" "pgadmin" {
  repository = aws_ecr_repository.pgadmin.name

  policy = <<EOF
{
  "rules": [
    {
      "rulePriority": 1,
      "description": "Keep last 10 images",
      "selection": {
        "tagStatus": "any",
        "countType": "imageCountMoreThan",
        "countNumber": 10
      },
      "action": {
        "type": "expire"
      }
    }
  ]
}
EOF
}

### modules/ecr/outputs.tf ###
output "repository_url" {
  description = "URL of the ECR repository"
  value       = aws_ecr_repository.pgadmin.repository_url
}

output "repository_arn" {
  description = "ARN of the ECR repository"
  value       = aws_ecr_repository.pgadmin.arn
}

### modules/ecr/variables.tf ###
variable "name" {
  type        = string
  description = "Name of the ECR repository"
  default     = "pgadmin"
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to ECR resources"
  default     = {}
}

### modules/ecs/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/ecs/main.tf ###
##############################
# ECS Cluster for pgAdmin    #
##############################

resource "aws_ecs_cluster" "this" {
  name = "${var.name}-cluster"
  tags = merge(local.common_tags, { Name = "${var.name}-cluster" })
}

##############################
# CloudWatch Logs            #
##############################
resource "aws_cloudwatch_log_group" "ecs" {
  name              = "/ecs/${var.name}"
  retention_in_days = 14
  tags              = local.common_tags
}

##############################
# Task Definition for pgAdmin #
##############################

resource "aws_ecs_task_definition" "this" {
  family                   = "${var.name}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.cpu
  memory                   = var.memory
  execution_role_arn       = var.execution_role_arn
  task_role_arn            = var.task_role_arn

  container_definitions = jsonencode([
    {
      name      = "pgadmin"
      image     = "${var.ecr_repo_url}:${var.image_tag}"
      essential = true
      portMappings = [
        {
          containerPort = var.container_port
          hostPort      = var.container_port
          protocol      = "tcp"
        }
      ]
      mountPoints = [
        {
          sourceVolume  = "efs-volume"
          containerPath = "/var/lib/pgadmin"
          readOnly      = false
        }
      ]
      secrets = [
        {
          name      = "PGADMIN_DEFAULT_EMAIL"
          valueFrom = var.pgadmin_secret_arn
        },
        {
          name      = "PGADMIN_DEFAULT_PASSWORD"
          valueFrom = var.pgadmin_secret_arn
        }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "ecs"
        }
      }
    }
  ])

  volume {
    name = "efs-volume"
    efs_volume_configuration {
      file_system_id          = var.efs_id
      transit_encryption      = "ENABLED"
      authorization_config {
        access_point_id = var.efs_access_point_id
      }
    }
  }

  tags = local.common_tags
}

##############################
# ECS Service for pgAdmin    #
##############################

resource "aws_ecs_service" "this" {
  name            = "${var.name}-service"
  cluster         = aws_ecs_cluster.this.id
  task_definition = aws_ecs_task_definition.this.arn
  desired_count   = var.desired_count
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = var.private_subnet_ids
    assign_public_ip = false
    security_groups  = [var.ecs_sg_id]
  }

  deployment_controller {
    type = "ECS"
  }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  enable_execute_command = true

  depends_on = [var.alb_target_group_arn]

  tags = local.common_tags
}

### modules/ecs/outputs.tf ###
output "ecs_cluster_id" {
  value       = aws_ecs_cluster.this.id
  description = "ECS cluster ID"
}

output "ecs_service_name" {
  value       = aws_ecs_service.this.name
  description = "ECS service name"
}

output "ecs_cluster_name" {
  value       = aws_ecs_cluster.this.name
  description = "ECS cluster name (used for CodeDeploy)"
}

### modules/ecs/variables.tf ###
variable "name" {
  type        = string
  default     = "pgadmin"
  description = "Name prefix"
}

variable "cpu" {
  type        = string
  default     = "512"
  description = "Task CPU"
}

variable "memory" {
  type        = string
  default     = "1024"
  description = "Task Memory"
}

variable "container_port" {
  type        = number
  default     = 80
  description = "Port where pgAdmin listens"
}

variable "desired_count" {
  type        = number
  default     = 1
  description = "Number of tasks to run"
}

variable "execution_role_arn" {
  type        = string
  description = "ECS execution role ARN"
}

variable "task_role_arn" {
  type        = string
  description = "ECS task role ARN"
}

variable "ecr_repo_url" {
  type        = string
  description = "ECR repo URL for pgAdmin image"
}

variable "efs_id" {
  type        = string
  description = "EFS File System ID"
}

variable "efs_access_point_id" {
  type        = string
  description = "EFS Access Point ID for pgAdmin"
}

variable "ecs_sg_id" {
  type        = string
  description = "ECS Security Group ID"
}

variable "public_subnet_ids" {
  type        = list(string)
  description = "Public subnets for ECS tasks"
}

variable "pgadmin_secret_arn" {
  type        = string
  description = "Secrets Manager ARN for pgAdmin login"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Common tags"
}

variable "alb_target_group_arn" {
  type        = string
  description = "ALB Target Group ARN"
}

variable "private_subnet_ids" {
  type        = list(string)
  description = "Private subnet IDs for ECS tasks"
}

variable "region" {
  type        = string
  description = "AWS region for ECS resources (used in log group, etc.)"
}

variable "image_tag" {
  type        = string
  description = "Tag of the Docker image to deploy"
}

### modules/efs/locals.tf ###
locals {
  name = var.name
  tags = merge({ Module = "efs" }, var.tags)
}

### modules/efs/main.tf ###
data "aws_vpc" "this" {
  id = var.vpc_id
}

# Optional SG creation (allow NFS from VPC CIDR)
resource "aws_security_group" "efs" {
  count  = var.create_security_group && var.security_group_id == null ? 1 : 0
  name   = "${local.name}-efs-sg"
  vpc_id = var.vpc_id
  tags   = merge(local.tags, { Name = "${local.name}-efs-sg" })

  ingress {
    description = "Allow NFS from VPC"
    from_port   = 2049
    to_port     = 2049
    protocol    = "tcp"
    cidr_blocks = [data.aws_vpc.this.cidr_block]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

locals {
  efs_sg_id = var.security_group_id != null ? var.security_group_id : (
    var.create_security_group ? aws_security_group.efs[0].id : null
  )
}

resource "aws_efs_file_system" "this" {
  creation_token = local.name
  encrypted      = true
  tags           = merge(local.tags, { Name = "${local.name}-efs" })
}

# One mount target per private subnet
resource "aws_efs_mount_target" "this" {
  for_each = { for idx, sid in var.subnet_ids : idx => sid }

  file_system_id  = aws_efs_file_system.this.id
  subnet_id       = each.value
  security_groups = local.efs_sg_id == null ? [] : [local.efs_sg_id]
}

# Create multiple access points, one per app (pgadmin, marquez, ...)
resource "aws_efs_access_point" "ap" {
  for_each      = { for ap in var.access_points : ap.name => ap }
  file_system_id = aws_efs_file_system.this.id

  root_directory {
    path = each.value.path
    creation_info {
      owner_uid   = each.value.uid
      owner_gid   = each.value.gid
      permissions = each.value.permissions
    }
  }

  tags = merge(local.tags, {
    Name = "${local.name}-ap-${each.key}"
    App  = each.key
  })
}

### modules/efs/outputs.tf ###
output "file_system_id" {
  description = "EFS filesystem ID"
  value       = aws_efs_file_system.this.id
}

output "security_group_id" {
  description = "Security group ID used for EFS mount targets (if created)"
  value       = local.efs_sg_id
}

output "access_point_ids_by_name" {
  description = "Map of access point name to ID"
  value       = { for k, v in aws_efs_access_point.ap : k => v.id }
}

### modules/efs/variables.tf ###
variable "name" {
  type        = string
  description = "Name prefix for EFS resources"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID where EFS will be created"
}

variable "subnet_ids" {
  type        = list(string)
  description = "List of private subnet IDs for EFS mount targets"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply to resources"
}

variable "create_security_group" {
  type        = bool
  default     = true
  description = "If true, create an SG that allows NFS from the VPC CIDR"
}

variable "security_group_id" {
  type        = string
  default     = null
  description = "If provided, use this SG for EFS mount targets instead of creating one"
}

variable "access_points" {
  description = "List of access points to create"
  type = list(object({
    name        = string
    path        = string
    uid         = number
    gid         = number
    permissions = string
  }))
  default = []
}

### modules/iam/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/iam/main.tf ###
###########################
# ECS Execution Role      #
###########################
resource "aws_iam_role" "execution_role" {
  name               = "${var.name}-ecs-execution-role"
  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume_role.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "execution_role_policy" {
  role       = aws_iam_role.execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

# Allow execution role to read Secrets Manager
resource "aws_iam_role_policy" "execution_role_secrets" {
  name = "${var.name}-ecs-execution-secrets"
  role = aws_iam_role.execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = "*" # TODO: restrict to pgadmin secret ARN if you want
      }
    ]
  })
}

###########################
# ECS Task Role           #
###########################
resource "aws_iam_role" "task_role" {
  name               = "${var.name}-ecs-task-role"
  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume_role.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "task_secrets_policy" {
  role       = aws_iam_role.task_role.name
  policy_arn = "arn:aws:iam::aws:policy/SecretsManagerReadWrite"
}

# Attach ECS Exec permissions (SSM)
resource "aws_iam_role_policy_attachment" "task_ssm_policy" {
  role       = aws_iam_role.task_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

###########################
# CodeDeploy Service Role #
###########################
resource "aws_iam_role" "codedeploy_service_role" {
  name               = "${var.name}-codedeploy-service-role"
  assume_role_policy = data.aws_iam_policy_document.codedeploy_assume.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "codedeploy_service_role_policy" {
  role       = aws_iam_role.codedeploy_service_role.name
  policy_arn = "arn:aws:iam::aws:policy/AWSCodeDeployRoleForECS"
}

###########################
# Assume Role Policy Docs #
###########################
data "aws_iam_policy_document" "ecs_task_assume_role" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ecs-tasks.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "codedeploy_assume" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["codedeploy.amazonaws.com"]
    }
  }
}

### modules/iam/outputs.tf ###
output "execution_role_arn" {
  value       = aws_iam_role.execution_role.arn
  description = "ECS Execution Role ARN"
}

output "task_role_arn" {
  value       = aws_iam_role.task_role.arn
  description = "ECS Task Role ARN"
}

output "codedeploy_service_role_arn" {
  value       = aws_iam_role.codedeploy_service_role.arn
  description = "CodeDeploy Service Role ARN"
}

### modules/iam/variables.tf ###
variable "name" {
  description = "Prefix name for IAM roles"
  type        = string
}

variable "tags" {
  description = "Tags for IAM resources"
  type        = map(string)
  default     = {}
}

### modules/secrets/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/secrets/main.tf ###
#############################
# Secrets for pgAdmin Login #
#############################

# Always create a random suffix
resource "random_string" "suffix" {
  length  = 5
  special = false
}

resource "aws_secretsmanager_secret" "pgadmin" {
  # For prod/uat → fixed name
  # For test → you can pass a flag later, but by default just use suffix
  name        = "${var.name}-credentials-${random_string.suffix.result}"
  description = "Credentials for pgAdmin default login"
  tags        = merge(local.common_tags, { Name = "${var.name}-secrets" })
}

resource "aws_secretsmanager_secret_version" "pgadmin" {
  secret_id     = aws_secretsmanager_secret.pgadmin.id
  secret_string = jsonencode({
    PGADMIN_DEFAULT_EMAIL    = var.pgadmin_email
    PGADMIN_DEFAULT_PASSWORD = var.pgadmin_password
  })
}

### modules/secrets/outputs.tf ###
output "pgadmin_secret_arn" {
  description = "ARN of the pgAdmin secret"
  value       = aws_secretsmanager_secret.pgadmin.arn
}

### modules/secrets/variables.tf ###
variable "name" {
  type        = string
  description = "Prefix for the secret name"
  default     = "pgadmin"
}

variable "pgadmin_email" {
  type        = string
  description = "Default pgAdmin login email"
}

variable "pgadmin_password" {
  type        = string
  description = "Default pgAdmin login password"
  sensitive   = true
}

variable "tags" {
  type        = map(string)
  description = "Tags for the secret"
  default     = {}
}

### modules/security_groups/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/security_groups/main.tf ###
resource "random_string" "suffix" {
  length  = 5
  special = false
}

#####################################
# Security Group for ECS Tasks      #
#####################################
resource "aws_security_group" "ecs" {
  name        = "${var.name}-ecs-sg-${random_string.suffix.result}"
  description = "Security group for ECS tasks"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = var.container_port
    to_port     = var.container_port
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = var.tags
}

#####################################
# Security Group for EFS            #
#####################################
resource "aws_security_group" "efs" {
  name        = "${var.name}-efs-sg-${random_string.suffix.result}"
  description = "Security group for EFS access"
  vpc_id      = var.vpc_id

  ingress {
    from_port       = 2049
    to_port         = 2049
    protocol        = "tcp"
    security_groups = [aws_security_group.ecs.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = var.tags
}

### modules/security_groups/outputs.tf ###
output "ecs_sg_id" {
  description = "Security group ID for ECS tasks"
  value       = aws_security_group.ecs.id
}

output "efs_sg_id" {
  description = "Security group ID for EFS"
  value       = aws_security_group.efs.id
}

### modules/security_groups/variables.tf ###
variable "name" {
  type        = string
  description = "Base name prefix for security groups"
  default     = "pgadmin"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "container_port" {
  type        = number
  description = "Port where ECS containers listen"
  default     = 80
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply"
  default     = {}
}

### modules/vpc_endpoints/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### modules/vpc_endpoints/main.tf ###
############################
# Optional Endpoint SG
############################
resource "aws_security_group" "endpoints" {
  count       = var.sg_id == null ? 1 : 0
  name        = "${var.name}-vpce-sg"
  description = "Allow HTTPS from VPC for VPC Interface Endpoints"
  vpc_id      = var.vpc_id

  ingress {
    protocol    = "tcp"
    from_port   = 443
    to_port     = 443
    cidr_blocks = ["0.0.0.0/0"]# Restrict to VPC CIDR
  }

  egress {
    protocol    = "-1"
    from_port   = 0
    to_port     = 0
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = local.common_tags
}

locals {
  vpce_sg_id = var.sg_id != null ? var.sg_id : aws_security_group.endpoints[0].id
}

############################
# Interface Endpoints
############################

# ECR API
resource "aws_vpc_endpoint" "ecr_api" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ecr.api"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ecr-api" })
}

# ECR DKR (image pulls)
resource "aws_vpc_endpoint" "ecr_dkr" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ecr.dkr"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ecr-dkr" })
}

# CloudWatch Logs
resource "aws_vpc_endpoint" "logs" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.logs"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-logs" })
}

# Secrets Manager
resource "aws_vpc_endpoint" "secretsmanager" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.secretsmanager"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-secrets" })
}

# SSM endpoints for ECS Exec
resource "aws_vpc_endpoint" "ssm" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ssm"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ssm" })
}

resource "aws_vpc_endpoint" "ssmmessages" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ssmmessages"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ssmmessages" })
}

resource "aws_vpc_endpoint" "ec2messages" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ec2messages"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ec2messages" })
}

############################
# S3 Gateway Endpoint
############################
resource "aws_vpc_endpoint" "s3" {
  count             = length(var.private_route_table_ids) > 0 ? 1 : 0
  vpc_id            = var.vpc_id
  service_name      = "com.amazonaws.${var.region}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = var.private_route_table_ids
  tags              = merge(local.common_tags, { Name = "${var.name}-s3" })
}

### modules/vpc_endpoints/outputs.tf ###
output "security_group_id" {
  description = "Security group ID attached to interface endpoints"
  value       = local.vpce_sg_id
}

output "endpoint_ids" {
  description = "IDs of created endpoints"
  value = {
    ecr_api      = aws_vpc_endpoint.ecr_api.id
    ecr_dkr      = aws_vpc_endpoint.ecr_dkr.id
    logs         = aws_vpc_endpoint.logs.id
    secrets      = aws_vpc_endpoint.secretsmanager.id
    ssm          = aws_vpc_endpoint.ssm.id
    ssmmessages  = aws_vpc_endpoint.ssmmessages.id
    ec2messages  = aws_vpc_endpoint.ec2messages.id
    s3_gateway   = length(aws_vpc_endpoint.s3) > 0 ? aws_vpc_endpoint.s3[0].id : null
  }
}

### modules/vpc_endpoints/variables.tf ###
variable "name" {
  type        = string
  description = "Prefix for resources"
  default     = "pgadmin"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "region" {
  type        = string
  description = "AWS region"
}

variable "subnet_ids" {
  type        = list(string)
  description = "Private subnets for interface endpoints"
}

variable "sg_id" {
  type        = string
  default     = null
  description = "Optional SG for endpoints; if null, one is created"
}

variable "private_route_table_ids" {
  type        = list(string)
  default     = []
  description = "Private route table IDs for S3 Gateway endpoint"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags"
}
